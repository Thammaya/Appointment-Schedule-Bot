/**
 * 1. INITIALIZATION
 */
const { BigQuery } = require('@google-cloud/bigquery');
const bigquery = new BigQuery();

/**
 * 2. ENTRY POINT: appointmentWebhook
 */
exports.appointmentWebhook = async (req, res) => {
    const path = req.path;

    try {
        if (path === '/validatePatient') {
            await handleValidation(req, res);
        } else if (path === '/getAvailableSlots') {
            await handleSlotRetrieval(req, res);
        } else if (path === '/bookSlot') {
            await handleBooking(req, res);
        } else {
            res.status(404).send({ error: "Endpoint not found" });
        }
    } catch (error) {
        console.error('System Error:', error);
        res.status(500).send({ 
            fulfillment_response: { 
                messages: [{ text: { text: ["A system error occurred. Please call back later."] } }] 
            } 
        });
    }
};

/**
 * VALIDATION LOGIC
 */
async function handleValidation(req, res) {
    const params = req.body.sessionInfo?.parameters || {};
    const patientId = params.patient_id; 
    const dob = params.dob;
    const ssn4 = params.ssn4;

    // SSN4 is mandatory; we need at least one of the other two
    if (!ssn4 || (!patientId && !dob)) {
        return res.status(200).send({ sessionInfo: { parameters: { authenticated: false } } });
    }

    let query;
    let queryParams;
    
    // Replace 'your-project-id' with your actual Project ID
    const projectTable = `your-project-id.appointment_system.master_patient`;

    if (patientId) {
        query = `
            SELECT patient_name, patient_id FROM \`${projectTable}\`
            WHERE patient_id = @pid AND ssn4 = @ssn LIMIT 1`;
        queryParams = { pid: patientId, ssn: ssn4 };
    } else {
        query = `
            SELECT patient_name, patient_id FROM \`${projectTable}\`
            WHERE dob = @dob AND ssn4 = @ssn LIMIT 1`;
        queryParams = { dob: dob, ssn: ssn4 };
    }

    try {
        const [rows] = await bigquery.query({ query, params: queryParams });

        if (rows.length > 0) {
            res.status(200).send({
                sessionInfo: {
                    parameters: {
                        authenticated: true,
                        patient_name: rows[0].patient_name,
                        patient_id: rows[0].patient_id 
                    }
                }
            });
        } else {
            res.status(200).send({ sessionInfo: { parameters: { authenticated: false } } });
        }
    } catch (err) {
        console.error("BQ Query Error:", err);
        res.status(500).send({ error: "Database query failed" });
    }
}

/**
 * SLOT RETRIEVAL LOGIC
 */
async function handleSlotRetrieval(req, res) {
    const { department, futureOnly } = req.body;
    const tableName = `your-project-id.appointment_system.${department.toLowerCase()}_slots`;

    const limit = futureOnly ? 3 : 10;
    const query = `
        SELECT slot_id, slot_date, slot_time FROM \`${tableName}\`
        WHERE status = 'Available'
        ORDER BY slot_date ASC, slot_time ASC LIMIT ${limit}`;

    try {
        const [slots] = await bigquery.query(query);
        res.status(200).send(slots);
    } catch (err) {
        res.status(500).send({ error: "Failed to fetch slots" });
    }
}

/**
 * BOOKING LOGIC
 */
async function handleBooking(req, res) {
    const { department, slot_id, patient_id } = req.body;
    const tableName = `your-project-id.appointment_system.${department.toLowerCase()}_slots`;

    const query = `
        UPDATE \`${tableName}\`
        SET status = 'Booked', patient_id = @pid
        WHERE slot_id = @sid AND status = 'Available'`;
    
    try {
        const [job] = await bigquery.createQueryJob({
            query,
            params: { pid: patient_id, sid: slot_id }
        });
        
        await job.getQueryResults();

        if (job.metadata.statistics.query.numDmlAffectedRows > 0) {
            res.status(200).send({ success: true });
        } else {
            res.status(409).send({ success: false, error: "Slot already booked" });
        }
    } catch (err) {
        res.status(500).send({ error: "Booking failed" });
    }
}
